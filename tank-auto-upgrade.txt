// TANK + UPGRADE

setInterval(handlePots, 250);
setInterval(attackTarget, 250);
setInterval(loot, 250);
setInterval(upgradeItem, 1000);

// HEAL + MP
function handlePots() {
    //Heal and restore mana if required
    if (character.hp < 1600 && new Date() > parent.next_potion) {
    buy("hpot1",1);
        parent.use('hp');
    }
    if (character.mp < 500 && new Date() > parent.next_potion) {
    buy("mpot1",1);
        parent.use('mp');
    }
}

// ATTACK
function attackTarget() {
    var target = get_targeted_monster();
    if (!target) {
        target = get_closest_monster({m_type_priority: "dknight2", m_type_secondary: "dknight2"});
        if (target)
			change_target(target);
        else {
            set_message("No Monsters");
            return;
        }
    }
    
    if (!in_attack_range(target)) {
        move(
            character.real_x+(target.real_x-character.real_x)/2,
            character.real_y+(target.real_y-character.real_y)/2
            );
    }
    else if (can_attack(target)) {
        set_message("Attacking");
        attack(target);
    }
}

// CUSTOM MTYPE TARGETING
function get_closest_monster(args) {
    //args:
    // m_type_priority - the monster you want to attack (bosses)
    // m_type_secondary -the monster you attack when your boss is not there
    // target: Only return monsters that target this "name" or player object
    // no_target: Only pick monsters that don't have any target
    var min_d=999999,target=null;
    
    if(args.m_type_priority == null && args.m_type_secondary == null){return null;}
    if(args && args.target && args.target.name) args.target=args.target.name;

    for(id in parent.entities){
        var current=parent.entities[id];
        if(current.type!="monster" || current.dead) continue;
        if(current.target!=null && current.target!=character.name) continue;
        var c_dist=parent.distance(character,current);
        if(current.mtype == args.m_type_priority){
            return current;
        }
        else if(c_dist<min_d && current.mtype == args.m_type_secondary){
            min_d=c_dist;
            target=current;
        }
        
    }
    return target;
}

// UPGRADE ITEM	
function upgradeItem() {
	var buyScroll0 = false;
	var buyScroll1 = false;
	var invLength = character.items.length;
	
	// CHECK WHOLE INVENTORY
	for (var i = 0; i < invLength; i++) {
		// CHECK FOR ITEM TO UPGRADE
		if (character.items[i] && character.items[i].name == "shield") {
			// CHECK FOR SCROLLS, DO NOT BUY IF ANY EXIST
			for (var j = 0; j < invLength; j++) {
				if (character.items[j] && character.items[j].name == "scroll0") {
					buyScroll0 = false;
					break;
				}
				else buyScroll0 = true;
				
				if (character.items[j] && character.items[j].name == "scroll1") {
					buyScroll1 = false;
					break;
				}
				else buyScroll1 = true;
			}
			// END OF CHECK SCROLLS
			
			// BUY + UPGRADE
			if (character.items[i].level < 4) {
				if (character.gold > 1000) {
					if (buyScroll0 == true) {	
						buy("scroll0", 1);
						// LOOK FOR SCROLL THEN UPGRADE
						for (var k = 0; k < invLength; k++) upgrade(i, k);
					}
				}
			}
			else if (character.items[i].level < 7) {
				if (character.gold > 50000) {
					if (buyScroll1 == true) {
						buy("scroll1", 1);
						// LOOK FOR SCROLL THEN UPGRADE
						for (var k = 0; k < invLength; k++) upgrade(i, k);
					}
				}
			}
			// END OF BUY + UPGRADE
		}
	}
}